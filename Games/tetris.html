<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelNebula - Tetris</title>
    <link rel="icon" href="../Pictures/Logo.png" type="image/png">
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            background-image: url('../Pictures/background.png');
            background-size: cover;
            background-position: center;
            font-family: Arial, sans-serif;
            color: white;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding-top: 0px;
        }
        .header {
            margin-top: 20px;
            text-align: center;
        }
        .header h1 {
            font-size: 60px;
            margin: 0;
        }
        .header h2 {
            font-size: 40px;
            margin: 0;
        }
        .menu {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 20px;
        }
        .menu a {
            text-decoration: none;
            color: white;
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        .menu a:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .menu a.game {
            text-decoration: underline;
        }
        .menu a.logout {
            position: absolute;
            left: 1320px;
        }
        .tetris-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            position: relative;
        }
        .tetris-board {
            display: grid;
            grid-template-columns: repeat(10, 20px);
            grid-template-rows: repeat(20, 20px);
            gap: 1px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border: 2px solid white;
            position: relative;
        }
        .block {
            width: 20px;
            height: 20px;
            background-color: grey;
            border: 1px solid #666;
        }
        .empty {
            background-color: transparent;
            border: 1px solid grey;
        }
        .score-container {
    	    display: flex;
            flex-direction: row;
            gap: 20px;
            margin-top: 10px;
            font-size: 20px;
            font-weight: bold;
	}

	.score, .levels-destroyed, .high-score {
    	    margin: 0;
	}
        .new-game {
            margin-top: 10px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .new-game:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
            font-weight: bold;
            color: red;
            display: none;
        }
        footer {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 12px;
            color: white;
        }
    </style>
</head>
<body>
    <div class="menu">
        <a href="Home.html">Home</a>
        <a href="Games.html" class="Games">Games/Proxies</a>
        <a href="tetris.html" class="game">Tetris</a>
        <a href="#" class="logout" onclick="logout()">Logout</a>
    </div>

    <div class="header">
        <h2>Pixel Nebula</h2>
    </div>

    <div class="tetris-container">
        <div class="tetris-board" id="tetris-board">
            <!-- Tetris grid will be generated here by JavaScript -->
        </div>
        <div class="game-over" id="game-over">Game Over!</div>
        <div class="score-container">
    	    <div class="score" id="score">Score: 0</div>
    	    <div class="levels-destroyed" id="levels-destroyed">Levels Destroyed: 0</div>
    	    <div class="high-score" id="high-score">High Score: 0</div>
	</div>

        <button class="new-game" onclick="startNewGame()">New Game</button>
    </div>

    <footer>
        &copy; 2024 Pixel Nebula. All rights reserved.
    </footer>

    <script>
    const rows = 20;
    const cols = 10;
    const tetrisBoard = document.getElementById('tetris-board');
    const gameOverText = document.getElementById('game-over');
    let board = [];
    let currentBlock = null;
    let score = 0;
    let levelsDestroyed = 0; // Add this variable
    let gameInterval;
    let downInterval;
    let gameRunning = false;

    const blocks = [
        // Tetrimino shapes and rotations
        [[1, 1, 1, 1]], // I
        [[1, 1], [1, 1]], // O
        [[0, 1, 0], [1, 1, 1]], // T
        [[1, 1, 0], [0, 1, 1]], // S
        [[0, 1, 1], [1, 1, 0]], // Z
        [[1, 1, 1], [1, 0, 0]], // L
        [[1, 1, 1], [0, 0, 1]]  // J
    ];

    function createBoard() {
        tetrisBoard.innerHTML = '';
        board = Array.from({ length: rows }, () => Array(cols).fill(0));
        for (let i = 0; i < rows * cols; i++) {
            const block = document.createElement('div');
            block.className = 'empty'; // Initially, all blocks are empty
            tetrisBoard.appendChild(block);
        }
    }

    function startNewGame() {
        score = 0;
        levelsDestroyed = 0; // Reset the levels destroyed counter
        updateScore();
        updateLevelsDestroyed(); // Update the display for levels destroyed
        createBoard();
        gameOverText.style.display = 'none';
        gameRunning = true;
        clearInterval(gameInterval);
        clearInterval(downInterval);
        gameInterval = setInterval(gameLoop, 500); // Game loop runs every 500ms
        spawnBlock();
    }

    function spawnBlock() {
        const randomIndex = Math.floor(Math.random() * blocks.length);
        currentBlock = {
            shape: blocks[randomIndex],
            row: 0,
            col: Math.floor(cols / 2) - 1
        };
        if (!canPlaceBlock(currentBlock.shape, currentBlock.row, currentBlock.col)) {
            endGame(); // If a block can't be placed, the game is over
        }
    }

    function gameLoop() {
        if (!gameRunning) return;
        if (canPlaceBlock(currentBlock.shape, currentBlock.row + 1, currentBlock.col)) {
            currentBlock.row++;
            updateBoard();
        } else {
            placeBlock();
            checkLines();
            spawnBlock();
        }
    }

    function canPlaceBlock(shape, row, col) {
        for (let r = 0; r < shape.length; r++) {
            for (let c = 0; c < shape[r].length; c++) {
                if (shape[r][c]) {
                    const newRow = row + r;
                    const newCol = col + c;
                    if (
                        newRow >= rows || newCol < 0 || newCol >= cols ||
                        board[newRow][newCol]
                    ) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    function placeBlock() {
        for (let r = 0; r < currentBlock.shape.length; r++) {
            for (let c = 0; c < currentBlock.shape[r].length; c++) {
                if (currentBlock.shape[r][c]) {
                    board[currentBlock.row + r][currentBlock.col + c] = 1;
                }
            }
        }
        updateBoard();
    }

    function updateBoard() {
        const allBlocks = tetrisBoard.children;
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const index = r * cols + c;
                allBlocks[index].className = board[r][c] ? 'block' : 'empty';
            }
        }

        // Display the current block
        for (let r = 0; r < currentBlock.shape.length; r++) {
            for (let c = 0; c < currentBlock.shape[r].length; c++) {
                if (currentBlock.shape[r][c]) {
                    const index = (currentBlock.row + r) * cols + (currentBlock.col + c);
                    allBlocks[index].className = 'block';
                }
            }
        }
    }

    function rotateBlock() {
        const rotatedShape = currentBlock.shape[0].map((_, index) =>
            currentBlock.shape.map(row => row[index]).reverse()
        );
        if (canPlaceBlock(rotatedShape, currentBlock.row, currentBlock.col)) {
            currentBlock.shape = rotatedShape;
            updateBoard();
        }
    }

    function moveBlockLeft() {
        if (canPlaceBlock(currentBlock.shape, currentBlock.row, currentBlock.col - 1)) {
            currentBlock.col--;
            updateBoard();
        }
    }

    function moveBlockRight() {
        if (canPlaceBlock(currentBlock.shape, currentBlock.row, currentBlock.col + 1)) {
            currentBlock.col++;
            updateBoard();
        }
    }

    function dropBlockFaster() {
        if (downInterval) clearInterval(downInterval);
        downInterval = setInterval(() => {
            if (canPlaceBlock(currentBlock.shape, currentBlock.row + 1, currentBlock.col)) {
                currentBlock.row++;
                updateBoard();
                score += 5; // Award 5 points for each second the down arrow is held
                updateScore();
                updateHighScore();
            } else {
                clearInterval(downInterval);
            }
        }, 100);
    }

    function stopDroppingFaster() {
        if (downInterval) clearInterval(downInterval);
    }

    function checkLines() {
        let linesDestroyed = 0;
        for (let r = rows - 1; r >= 0; r--) {
            if (board[r].every(cell => cell)) {
                linesDestroyed++;
                score += 10;
                board.splice(r, 1); // Remove the completed line
                board.unshift(Array(cols).fill(0)); // Add an empty line at the top
                r++; // Recheck the same row after shifting
            }
        }
        if (linesDestroyed > 0) {
            // Update the levels destroyed count
            const levelsDestroyedElement = document.getElementById('levels-destroyed');
            let currentLevelsDestroyed = parseInt(levelsDestroyedElement.innerText.replace('Levels Destroyed: ', ''));
            levelsDestroyedElement.innerText = `Levels Destroyed: ${currentLevelsDestroyed + linesDestroyed}`;
        }
    }

    function updateScore() {
        document.getElementById('score').innerText = `Score: ${score}`;
    }

    function updateLevelsDestroyed() {
        document.getElementById('levels-destroyed').innerText = `Levels Destroyed: ${levelsDestroyed}`;
    }

    function endGame() {
        gameRunning = false;
        clearInterval(gameInterval);
        clearInterval(downInterval);
        gameOverText.style.display = 'block';
        updateHighScore();
    }

    function updateHighScore() {
        const highScoreElement = document.getElementById('high-score');
        const savedHighScore = parseInt(localStorage.getItem('Tetris-HighScore')) || 0;
        if (score > savedHighScore) {
            localStorage.setItem('Tetris-HighScore', score);
            highScoreElement.innerText = `High Score: ${score}`;
        } else {
            highScoreElement.innerText = `High Score: ${savedHighScore}`;
        }
    }

    window.onload = function() {
        if (localStorage.getItem('Tetris-HighScore') === null) {
            localStorage.setItem('Tetris-HighScore', '0');
        }
        updateHighScore(); // Update high score display on page load
    };

    document.addEventListener('keydown', (e) => {
        if (!gameRunning) return;
        switch (e.key) {
            case 'ArrowLeft':
                moveBlockLeft();
                break;
            case 'ArrowRight':
                moveBlockRight();
                break;
            case 'ArrowUp':
                rotateBlock();
                break;
            case 'ArrowDown':
                dropBlockFaster();
                break;
        }
    });

    document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowDown') {
            stopDroppingFaster();
        }
    });

    createBoard(); // Initial board setup
</script>

</body>
</html>
